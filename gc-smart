#!/bin/bash

# gc-smart
#
# Description:
# ------------
#
# This script automatically generates a commit message for staged changes in a
# Git repository. It works by generating a diff of the staged changes called
# staged_changes.diff, then feeding this diff into the ai_commit_helper.py
# script. The output is then saved to a file named tmp_commit_msg.txt. This
# file is then used as template for running the "git commit" command, allowing
# the user to review and edit the auto-generated commit message before
# finalizing the commit.
#
# Prerequisites:
# --------------
# - There should be staged changes in the current repository. 
# - ai_commit_helper.py should be located in the current directory or be available
#   trough the path variable. 
# - tmp_commit_msg.txt is used to store the generated commit message, and will 
#   be overwritten each time the function is run.
#   Ensure any important data in this file is backed up. 
# - tmp_commit_msg.txt has to be configured as commit template: 
#   git config --global commit.template tmp_commit_msg.txt

# Options:
# --------
# Run "gc-smart --help" to see the options, or just see below ;-)

# Print a detailed help message for the gc-smart script
print_help() {
    echo "Usage: gc-smart [OPTION]"
    echo ""
    echo "Automatically generate a commit message for staged changes in a Git repository."
    echo ""
    echo "Options:"
    echo "-h, --help          Display this help message."
    echo "--keep-files        Retain staged_changes.diff and tmp_commit_msg.txt after the commit process."
    echo "-q, --quick         Skip the preview of the AI generated commit message and commit directly."
}

# Check for --help or -h options
for arg in "$@"; do
    if [ "$arg" == "--help" ] || [ "$arg" == "-h" ]; then
        print_help
        exit 0
    fi
done

# Check if in a Git repository
if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository."
    exit 2
fi

# Check if there are staged changes
if git diff --cached --quiet; then
    echo "No staged changes to commit"
    exit 1
fi

# Check if the --keep-files argument is passed
KEEP_FILES=false
for arg in "$@"; do
    if [ "$arg" == "--keep-files" ]; then
        KEEP_FILES=true
        break
    fi
done

# Check for the existence of ai_commit_helper.py
if ! [[ -x "ai_commit_helper.py" ]] && ! command -v ai_commit_helper.py &> /dev/null; then
    echo "Error: ai_commit_helper.py not found or not executable."
    exit 2
fi

# Generate a diff of the staged changes
git diff --cached > staged_changes.diff

# Get the directory of the currently executing script
# Note, the ai_commit_helper.py script should always be in the same
# directory as the gc-smart script in that case.
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# Now use that directory to call ai_commit_helper.py
# Generate a commit message and save it to a temp file
python3 "$DIR/ai_commit_helper.py" staged_changes.diff > tmp_commit_msg.txt

# By default, set PREVIEW to true
PREVIEW=true

# Check for --quick or -q argument
for arg in "$@"; do
    if [ "$arg" == "--preview" ] || [ "$arg" == "-q" ]; then
        PREVIEW=false
        break
    fi
done

if $PREVIEW; then
    regenerate=true

    while $regenerate; do
        # Preview the auto-generated commit message
        echo -e "\nGenerated Commit Message:"
        echo -e "-------------------------\n"
        cat tmp_commit_msg.txt
        echo -e "\n----------------------------------------------------------------\n\n"

        # Ask the user if he wants to proceed or regenerate
        read -p "Options: 
        1. Continue with commit
        2. Regenerate commit message 
        3. Abort 

        Choose [1/2/3]: " choice

        case "$choice" in
            1)
                # Continue to commit logic below
                regenerate=false
                ;;
            2)
                # Regenerate commit message and preview again
                python3 "$DIR/ai_commit_helper.py" staged_changes.diff > tmp_commit_msg.txt

                ;;
            3)
                # Abort
                echo "Commit aborted."
				rm -f staged_changes.diff tmp_commit_msg.txt
                exit 1
                ;;
            *)
                echo "Invalid choice. Commit aborted."
                rm -f staged_changes.diff tmp_commit_msg.txt
				exit 1
                ;;
        esac
    done
fi

# Run git commit to start the commit process
git commit 2> git_error.log # redirect error messages to a log

if [ $? -ne 0 ]; then # if git commit failed
    if grep -q "you did not edit the message" git_error.log; then
        # Warn the user
		echo "Warning: You either did not make any changes to the commit" \
		"message or you exited without saving. It's a good practice to customize" \
		"commit messages for clarity."
        read -p "Do you want to proceed without further editing and commit nevertheless? (y/n) " choice
        case "$choice" in
            y|Y )
				# Bypass commit.templyte and directly provide a
				# message from the file
                git commit -m "$(cat tmp_commit_msg.txt)"
                ;;
            n|N )
                echo "Commit aborted."
                ;;
            * )
                echo "Invalid choice. Commit aborted."
                ;;
        esac
    else
        cat git_error.log # Display other errors if there are any
    fi
fi

# Delete error log
rm git_error.log

# Delete files if --keep-files argument is not passed
if ! $KEEP_FILES; then
    rm -f staged_changes.diff tmp_commit_msg.txt
fi
